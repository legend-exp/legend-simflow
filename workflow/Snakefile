# Copyright (C) 2023 Luigi Pertoldi <gipert@pm.me>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from pathlib import Path
from datetime import datetime

from dbetto import AttrsDict

import legenddataflowscripts as ldfs
from legendsimflow import patterns, aggregate, tier_evt, utils
from legendmeta import LegendMetadata

# TODO:
# - make global vars defined here all caps
# - think about how to merge the legend-metadata in the config
# - how to install the Julia stuff in the right way?


if not config:
    raise RuntimeError("you must set a config file with --configfile")

config.setdefault("benchmark", {"enabled": False})
make_tiers = config.get("make_tiers", ["stp", "hit"])
ldfs.workflow.utils.subst_vars_in_snakemake_config(workflow, config)
config = AttrsDict(config)
basedir = workflow.basedir

proctime = datetime.now().strftime("%Y%m%dT%H%M%SZ")

# NOTE: this will attempt a clone of legend-metadata, if the directory does not exist
# NOTE: don't use lazy=True, we need a fully functional TextDB
metadata = LegendMetadata(config.paths.metadata)
if "legend_metadata_version" in config:
    metadata.checkout(config.legend_metadata_version)
config["metadata"] = metadata

conda: f"{basedir}/envs/global.yaml"


wildcard_constraints:
    tier=r"\w+",
    simid=r"[-\w]+",
    jobid=r"\d+",
    runid=r"[-\w]+",
    hpge_detector=r"[VPBC]\w{6}",


onstart:
    print("INFO: starting workflow")

    utils.setup_logdir_link(config, proctime)

    if not config.benchmark:
        # instantiate Julia project
        print("INFO: instantiating Julia project")
        shell(
            "julia --project=workflow/src/legendsimflow/scripts -e 'using Pkg; Pkg.instantiate()'"
        )

        # make sure some packages are initialized before we begin to avoid race conditions
        # https://numba.readthedocs.io/en/stable/developer/caching.html#cache-sharing
        if not workflow.touch and "precompile_pkg" in config:
            print("INFO: pre-compiling Numba cache")
            shell(f"python -c 'import {", ".join(config.precompile_pkg)}'")


include: "rules/aux.smk"


for tier in make_tiers:

    include: f"rules/{tier}.smk"


def gen_target_all():
    if config.get("simlist", "*") in ("all", "*"):
        if "pdf" in make_tiers:
            return rules.gen_pdf_release.input
        elif "evt" in make_tiers:
            return rules.gen_all_tier_evt.input
        elif "hit" in make_tiers:
            return rules.gen_all_tier_hit.input
        elif "stp" in make_tiers:
            return (
                rules.gen_all_tier_stp.input,
                # aggregate.gen_list_of_all_plots_outputs(config, tier="stp"),
                # aggregate.gen_list_of_all_plots_outputs(config, tier="ver"),
            )
    else:
        return aggregate.process_simlist(config)


rule all:
    """Default rule.

    Makes all output files of the highest tier specified in the `make_tiers`
    configuration variable (holding a list of tiers) and all the simids listed
    in the `simlist` configuration variable.
    """
    default_target: True
    input:
        gen_target_all(),
