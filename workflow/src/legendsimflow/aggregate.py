# Copyright (C) 2023 Luigi Pertoldi <gipert@pm.me>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import logging
import time
from collections.abc import Iterable
from pathlib import Path

from dbetto import AttrsDict
from legendmeta.police import validate_dict_schema

from . import SimflowConfig, patterns
from .exceptions import SimflowConfigError
from .metadata import get_runlist, get_simconfig, simpars

log = logging.getLogger(__name__)

TIERS_ORDERED: list[str] = ["vtx", "stp", "opt", "hit", "evt", "cvt"]


def get_simid_njobs(config: SimflowConfig, simid: str) -> int:
    """Number of jobs that will be generated for a `tier.simid`.

    Based on the information contained in the `stp` tiers simulation
    configuration. If ``config.benchmark`` is true, this function always
    returns 1.
    """
    if "benchmark" in config and config.benchmark.get("enabled", False):
        return 1

    sconfig = get_simconfig(config, "stp", simid=simid)

    if "number_of_jobs" in sconfig:
        return sconfig.number_of_jobs
    return get_simconfig(config, "stp", simid=simid, field="number_of_jobs")


def gen_list_of_simid_inputs(
    config: SimflowConfig, tier: str, simid: str
) -> list[Path]:
    """Generate the list of input files for a `tier.simid`."""
    n_jobs = get_simid_njobs(config, simid)
    return patterns.input_simid_filenames(config, n_jobs, tier=tier, simid=simid)


def gen_list_of_simid_outputs(
    config: SimflowConfig, tier: str, simid: str, max_files: int | None = None
) -> list[Path]:
    """Generate the list of output files for a `tier.simid`."""
    n_jobs = get_simid_njobs(config, simid)
    if max_files is not None:
        n_jobs = min(n_jobs, max_files)
    return patterns.output_simid_filenames(config, n_jobs, tier=tier, simid=simid)


def gen_list_of_plots_outputs(config: SimflowConfig, tier: str, simid: str, **kwargs):
    """Generate the list of plots files for a `tier.simid`."""
    if tier == "hit":
        return [
            patterns.plot_tier_hit_observables_filename(config, simid=simid),
            *gen_list_of_dtmap_plots_outputs(config, simid, **kwargs),
            *gen_list_of_currmod_plots_outputs(config, simid, **kwargs),
        ]
    if tier == "stp":
        return [patterns.plot_tier_stp_vertices_filename(config, simid=simid)]
    return []


# simid independent stuff


def gen_list_of_all_simids(config: SimflowConfig) -> list[str]:
    r"""Generate a list of all `simid`\ s defined in the simflow.

    The list is generated by querying the ``stp`` tier configuration.
    """
    return get_simconfig(config, "stp").keys()


def gen_list_of_all_simid_outputs(config: SimflowConfig, tier: str) -> list[Path]:
    r"""Generate a list of all files that belong to a `tier`."""
    mlist = []
    slist = gen_list_of_all_simids(config)
    for simid in slist:
        mlist += gen_list_of_simid_outputs(config, tier, simid)

    return mlist


def gen_list_of_all_plots_outputs(
    config: SimflowConfig, tier: str, **kwargs
) -> list[Path]:
    r"""Generate a list of all plot files that belong to a `tier`."""
    mlist = []
    for simid in gen_list_of_all_simids(config):
        mlist += gen_list_of_plots_outputs(config, tier, simid, **kwargs)

    return mlist


# drift time maps


def crystal_meta(config: SimflowConfig, diode_meta: AttrsDict) -> AttrsDict:
    """Get the crystal metadata starting from the diode metadata."""
    ids = {"bege": "B", "coax": "C", "ppc": "P", "icpc": "V"}
    crystal_name = (
        ids[diode_meta.type]
        + format(diode_meta.production.order, "02d")
        + diode_meta.production.crystal
    )
    crystal_db = config.metadata.hardware.detectors.germanium.crystals
    if crystal_name in crystal_db:
        return crystal_db[crystal_name]
    return None


def start_key(config: SimflowConfig, runid: str) -> str:
    """Get the start key for a runid."""
    _, period, run, datatype = runid.split("-")
    return config.metadata.datasets.runinfo[period][run][datatype].start_key


def gen_list_of_hpges_valid_for_modeling(
    config: SimflowConfig, runid: str
) -> list[str]:
    """Make a sorted list of HPGe detectors for which we want to compute a model.

    It generates the list of deployed detectors in `runid` via the LEGEND
    channelmap, then checks if in the crystal metadata there's all the
    information required to generate a drift time map etc.

    Warning
    -------
    This function is expensive in terms of filesystem I/O! Do not call it
    multiple times or in hot loops.
    """
    timestamp = start_key(config, runid)
    metadata = config.metadata
    chmap = metadata.hardware.configuration.channelmaps.on(timestamp)
    statuses = metadata.datasets.statuses.on(timestamp)

    hpges = []
    for _, hpge in chmap.group("system").geds.items():
        # TEMPORARY HACK
        if hpge.name in ("V00050A"):
            continue

        # we don't model detectors that are OFF or AC
        if statuses[hpge.name].usability != "on":
            continue

        m = crystal_meta(
            config, metadata.hardware.detectors.germanium.diodes[hpge.name]
        )

        if m is not None:
            schema = {
                "impurity_curve": {"parameters": None, "corrections": {"scale": 0}}
            }

            if validate_dict_schema(
                m, schema, greedy=False, typecheck=False, verbose=False
            ):
                hpges.append(hpge.name)

    if len(hpges) == 0:
        msg = f"the list of HPGes valid for drift time map generation in {runid} is empty!"
        log.warning(msg)

    return sorted(hpges)


def gen_list_of_all_hpges_valid_for_modeling(
    config: SimflowConfig,
) -> dict[str, dict[str, int]]:
    """Generate the complete list of HPGe detectors valid for modeling.

    Find out which HPGe detectors are valid for each runid and their voltages.
    Returns the following dictionary:

    .. code-block::

        {
          'l200-p03-r000-phy': {'V00048A': 4200, ...},
          'l200-p03-r001-phy': {'V00050B': 3500, ...},
          ...
        }

    i.e. a mapping ``runid -> hpge -> voltage``.
    """
    start = time.time()

    all_runids = set()
    for simid in gen_list_of_all_simids(config):
        all_runids.update(get_runlist(config, simid))

    out = {}
    for runid in sorted(all_runids):
        hpges = gen_list_of_hpges_valid_for_modeling(config, runid)
        out[runid] = {hpge: get_hpge_voltage(config, hpge, runid) for hpge in hpges}
    print(  # noqa: T201
        f"DEBUG: gen_list_of_all_hpges_valid_for_modeling() took {time.time() - start:.1f} sec"
    )
    return out


def gen_list_of_all_runids(config) -> set[str]:
    """The full list of runids required in the Simflow."""
    return {
        runid
        for simid in gen_list_of_all_simids(config)
        for runid in get_runlist(config, simid)
    }


def get_hpge_voltage(config: SimflowConfig, hpge: str, runid: str) -> int:
    """Get the operational voltage for an HPGe in a given run.

    Returns the voltage as an integer.
    """
    try:
        opv = simpars(config.metadata, "geds.opv", runid)[hpge].operational_voltage_in_V
    except KeyError as e:
        msg = f"operational voltage for hpge {hpge} not found in run {runid}"
        raise KeyError(msg) from e
    return int(opv)


def gen_list_of_dtmaps(
    config: SimflowConfig, runid: str, cache: dict[str, dict[str, int]] | None = None
) -> list[Path]:
    """Generate the list of HPGe drift time map files for a `runid`."""
    if cache is None:
        hpges = gen_list_of_hpges_valid_for_modeling(config, runid)
        return [
            patterns.output_dtmap_filename(
                config,
                hpge_detector=hpge,
                hpge_voltage=get_hpge_voltage(config, hpge, runid),
            )
            for hpge in hpges
        ]
    # use the cache to avoid calling get_hpge_voltage()
    hpge_voltages = cache[runid]
    return [
        patterns.output_dtmap_filename(
            config,
            hpge_detector=hpge,
            hpge_voltage=voltage,
        )
        for hpge, voltage in hpge_voltages.items()
    ]


def gen_list_of_merged_dtmaps(config: SimflowConfig, simid: str) -> list[Path]:
    r"""Generate the list of (merged) HPGe drift time map files for all requested `runid`\ s."""
    return [
        patterns.output_dtmap_merged_filename(config, runid=runid)
        for runid in get_runlist(config, simid)
    ]


def gen_list_of_dtmap_plots_outputs(
    config: SimflowConfig, simid: str, cache: dict[str, dict[str, int]] | None = None
) -> list[Path]:
    """Generate the list of HPGe drift time map plot outputs."""
    files = set()
    for runid in get_runlist(config, simid):
        if cache is None:
            hpges = gen_list_of_hpges_valid_for_modeling(config, runid)
            for hpge in hpges:
                files.add(
                    patterns.plot_dtmap_filename(
                        config,
                        hpge_detector=hpge,
                        hpge_voltage=get_hpge_voltage(config, hpge, runid),
                    )
                )
        else:
            # use the cache to avoid calling get_hpge_voltage()
            for hpge, voltage in cache[runid].items():
                files.add(
                    patterns.plot_dtmap_filename(
                        config,
                        hpge_detector=hpge,
                        hpge_voltage=voltage,
                    )
                )
    return list(files)


def gen_list_of_currmods(
    config: SimflowConfig, runid: str, cache: dict[str, dict[str, int]] | None = None
) -> list[str]:
    """Generate the list of HPGe current model parameter files for a `runid`."""
    hpges = (
        gen_list_of_hpges_valid_for_modeling(config, runid)
        if cache is None
        else cache[runid].keys()
    )
    return [
        patterns.output_currmod_filename(config, hpge_detector=hpge, runid=runid)
        for hpge in hpges
    ]


def gen_list_of_merged_currmods(config: SimflowConfig, simid: str) -> list[Path]:
    r"""Generate the list of (merged) HPGe current model parameter files for all requested `runid`\ s."""
    return [
        patterns.output_currmod_merged_filename(config, runid=runid)
        for runid in get_runlist(config, simid)
    ]


def gen_list_of_currmod_plots_outputs(
    config: SimflowConfig, simid: str, cache: dict[str, dict[str, int]] | None = None
) -> list[Path]:
    """Generate the list of HPGe drift time map plot outputs."""
    files = []
    for runid in get_runlist(config, simid):
        hpges = (
            gen_list_of_hpges_valid_for_modeling(config, runid)
            if cache is None
            else cache[runid].keys()
        )
        for hpge in hpges:
            files.append(
                patterns.plot_currmod_filename(config, hpge_detector=hpge, runid=runid)
            )

    return files


def gen_list_of_eresmods(config: SimflowConfig, simid: str) -> list[Path]:
    r"""Generate the list of HPGe energy resolution model parameter files for all requested `runid`\ s."""
    return [
        patterns.output_eresmod_filename(config, runid=runid)
        for runid in get_runlist(config, simid)
    ]


# tier cvt


def gen_list_of_all_tier_cvt_outputs(config: SimflowConfig, **kwargs) -> list[Path]:
    """Generate the list of all ``cvt`` tier files in the Simflow."""
    return [
        patterns.output_tier_cvt_filename(config, simid=simid, **kwargs)
        for simid in gen_list_of_all_simids(config)
    ]


def process_simlist(
    config: SimflowConfig,
    simlist: Iterable[str] | None = None,
    make_tiers: Iterable[str] | None = None,
) -> list[Path]:
    """Produce a list of all output files that refer to a `simlist`.

    Each simlist item is ``<tier>.<simid>``. The tier is interpreted as the
    *latest* tier requested for that simid; outputs are produced cumulatively
    for all tiers up to (and including) that tier in `make_tiers`.
    """
    if simlist is None:
        simlist = config.simlist
    if make_tiers is None:
        make_tiers = TIERS_ORDERED

    # if it's a list, every item is a simid
    # otherwise, interpret as comma-separated list
    if not isinstance(simlist, list):
        simlist = simlist.split(",")

    mlist: list[Path] = []
    for line in simlist:
        parts = line.split(".")
        if len(parts) != 2:
            msg = (
                "simflow-config.simlist",
                f"item '{line}' is not in the format <tier>.<simid>",
            )
            raise SimflowConfigError(*msg)

        tier = parts[0].strip()
        simid = parts[1].strip()

        if tier not in make_tiers:
            msg = f"unknown tier {tier!r}"
            raise NotImplementedError(msg)

        # cumulative: build all tiers up to the requested one
        for t in make_tiers:
            mlist += gen_list_of_plots_outputs(config, t, simid)

            if t == "vtx":
                pass
            elif t in ("stp", "opt", "hit", "evt"):
                mlist += gen_list_of_simid_outputs(config, t, simid)
            elif t == "cvt":
                mlist.append(patterns.output_tier_cvt_filename(config, simid=simid))

    return mlist
