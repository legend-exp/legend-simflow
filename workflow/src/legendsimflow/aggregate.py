# Copyright (C) 2023 Luigi Pertoldi <gipert@pm.me>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from __future__ import annotations

import logging
from collections.abc import Iterable
from pathlib import Path

from dbetto import AttrsDict
from legendmeta.police import validate_dict_schema

from . import SimflowConfig, patterns
from .exceptions import SimflowConfigError
from .metadata import get_runlist, get_simconfig

log = logging.getLogger(__name__)


def get_simid_njobs(config: SimflowConfig, simid: str) -> int:
    """Number of jobs that will be generated for a `tier.simid`.

    Based on the information contained in the `stp` tiers simulation
    configuration. If ``config.benchmark`` is true, this function always
    returns 1.
    """
    if "benchmark" in config and config.benchmark.get("enabled", False):
        return 1

    sconfig = get_simconfig(config, "stp", simid=simid)

    if "number_of_jobs" in sconfig:
        return sconfig.number_of_jobs
    return get_simconfig(config, "stp", simid=simid, field="number_of_jobs")


def gen_list_of_simid_inputs(
    config: SimflowConfig, tier: str, simid: str
) -> list[Path]:
    """Generate the list of input files for a `tier.simid`."""
    n_jobs = get_simid_njobs(config, simid)
    return patterns.input_simid_filenames(config, n_jobs, tier=tier, simid=simid)


def gen_list_of_simid_outputs(
    config: SimflowConfig, tier: str, simid: str, max_files: int | None = None
) -> list[Path]:
    """Generate the list of output files for a `tier.simid`."""
    n_jobs = get_simid_njobs(config, simid)
    if max_files is not None:
        n_jobs = min(n_jobs, max_files)
    return patterns.output_simid_filenames(config, n_jobs, tier=tier, simid=simid)


def gen_list_of_plots_outputs(config: SimflowConfig, tier: str, simid: str):
    """Generate the list of plots files for a `tier.simid`."""
    if tier == "hit":
        return gen_list_of_dtmap_plots_outputs(config, simid)
    if tier == "stp":
        return [patterns.plot_tier_stp_vertices_filename(config, simid=simid)]
    return []


# simid independent stuff


def gen_list_of_all_simids(config: SimflowConfig) -> list[str]:
    r"""Generate a list of all `simid`\ s defined in the simflow.

    The list is generated by querying the ``stp`` tier configuration.
    """
    return get_simconfig(config, "stp").keys()


def gen_list_of_all_simid_outputs(config: SimflowConfig, tier: str) -> list[Path]:
    r"""Generate a list of all files that belong to a `tier`."""
    mlist = []
    slist = gen_list_of_all_simids(config)
    for simid in slist:
        mlist += gen_list_of_simid_outputs(config, tier, simid)

    return mlist


def gen_list_of_all_plots_outputs(config: SimflowConfig, tier: str) -> list[Path]:
    r"""Generate a list of all plot files that belong to a `tier`."""
    mlist = []
    for simid in gen_list_of_all_simids(config):
        mlist += gen_list_of_plots_outputs(config, tier, simid)

    return mlist


# drift time maps


def crystal_meta(config: SimflowConfig, diode_meta: AttrsDict) -> AttrsDict:
    """Get the crystal metadata starting from the diode metadata."""
    ids = {"bege": "B", "coax": "C", "ppc": "P", "icpc": "V"}
    crystal_name = (
        ids[diode_meta.type]
        + format(diode_meta.production.order, "02d")
        + diode_meta.production.crystal
    )
    crystal_db = config.metadata.hardware.detectors.germanium.crystals
    if crystal_name in crystal_db:
        return crystal_db[crystal_name]
    return None


def start_key(config: SimflowConfig, runid: str) -> str:
    """Get the start key for a runid."""
    _, period, run, datatype = runid.split("-")
    return config.metadata.datasets.runinfo[period][run][datatype].start_key


def gen_list_of_hpges_valid_for_dtmap(config: SimflowConfig, runid: str) -> list[str]:
    """Make a sorted list of HPGe detector for which we want to generate a drift time map.

    It generates the list of deployed detectors in `runid` via the LEGEND
    channelmap, then checks if in the crystal metadata there's all the
    information required to generate a drift time map.
    """
    chmap = config.metadata.hardware.configuration.channelmaps.on(
        start_key(config, runid)
    )

    hpges = []
    for _, hpge in chmap.group("system").geds.items():
        # TEMPORARY HACK
        if hpge.name in ("V00050A", "V13046A", "V00048B", "V14654A"):
            continue

        m = crystal_meta(
            config, config.metadata.hardware.detectors.germanium.diodes[hpge.name]
        )

        if m is not None:
            schema = {
                "impurity_curve": {"parameters": None, "corrections": {"scale": 0}}
            }

            if validate_dict_schema(
                m, schema, greedy=False, typecheck=False, verbose=False
            ):
                hpges.append(hpge.name)

    if len(hpges) == 0:
        msg = f"the list of HPGes valid for drift time map generation in {runid} is empty!"
        log.warning(msg)

    return sorted(hpges)


def gen_list_of_all_runids(config):
    """The full list of runids required in this workflow."""
    return {
        runid
        for simid in gen_list_of_all_simids(config)
        for runid in get_runlist(config, simid)
    }


def gen_list_of_dtmaps(config: SimflowConfig, runid: str) -> list[str]:
    """Generate the list of HPGe drift time map files for a `runid`."""
    hpges = gen_list_of_hpges_valid_for_dtmap(config, runid)
    return [
        patterns.output_dtmap_filename(config, hpge_detector=hpge, runid=runid)
        for hpge in hpges
    ]


def gen_list_of_merged_dtmaps(config: SimflowConfig, simid: str) -> list[str]:
    r"""Generate the list of (merged) HPGe drift time map files for all requested `runid`\ s."""
    return [
        patterns.output_dtmap_merged_filename(config, runid=runid)
        for runid in get_runlist(config, simid)
    ]


def gen_list_of_dtmap_plots_outputs(config: SimflowConfig, simid: str) -> set[str]:
    """Generate the list of HPGe drift time map plot outputs."""
    files = set()
    for runid in get_runlist(config, simid):
        for hpge in gen_list_of_hpges_valid_for_dtmap(config, runid):
            files.add(
                patterns.plot_dtmap_filename(config, hpge_detector=hpge, runid=runid)
            )

    return files


def gen_list_of_all_dtmap_plots_outputs(config: SimflowConfig) -> set[str]:
    """Generate the list of HPGe drift time map plot outputs."""
    files = set()
    for simid in gen_list_of_all_simids(config):
        files.update(gen_list_of_dtmap_plots_outputs(config, simid))

    return files


def gen_list_of_currmods(config: SimflowConfig, runid: str) -> list[str]:
    """Generate the list of HPGe current model parameter files for a `runid`."""
    hpges = gen_list_of_hpges_valid_for_dtmap(config, runid)
    return [
        patterns.output_currmod_filename(config, hpge_detector=hpge, runid=runid)
        for hpge in hpges
    ]


def gen_list_of_merged_currmods(config: SimflowConfig, simid: str) -> list[str]:
    r"""Generate the list of (merged) HPGe current model parameter files for all requested `runid`\ s."""
    return [
        patterns.output_currmod_merged_filename(config, runid=runid)
        for runid in get_runlist(config, simid)
    ]


def process_simlist(
    config: SimflowConfig, simlist: Iterable[str] | None = None
) -> list[Path]:
    """Produce a list of all output files that refer to a `simlist`

    A "simlist" is a list of strings of the format ``<tier>.<simid>``, used to
    instruct the Simflow about which tiers and simulations it should process.
    The simlist should be specified as a field in `config`, located at
    `config.simlist`.

    This function returns the list of all files that the Simflow has to produce
    for all identifiers.

    Parameters
    ----------
    config
        :class:`SimflowConfig` object.
    simlist
        supply the simlist, if not present in `config`.
    """
    if simlist is None:
        simlist = config.simlist

    # if it's a list, every item is a simid
    # otherwise, interpret as comma-separated list
    if not isinstance(simlist, list):
        simlist = simlist.split(",")

    mlist = []
    for line in simlist:
        # each line is in the format <tier>.<simid>
        if len(line.split(".")) != 2:
            msg = (
                "simflow-config.simlist",
                f"item '{line}' is not in the format <tier>.<simid>",
            )
            raise SimflowConfigError(*msg)

        tier = line.split(".")[0].strip()
        simid = line.split(".")[1].strip()

        mlist += gen_list_of_plots_outputs(config, tier, simid)
        if tier in ("vtx", "stp", "opt", "hit"):
            mlist += gen_list_of_simid_outputs(config, tier, simid)
        elif tier in ("evt", "pdf"):
            raise NotImplementedError()

    return mlist
